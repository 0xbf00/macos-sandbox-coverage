"""
gather_logs

(c) Jakob Rieck 2018

Tool to collect sandbox logs for a given application. Sandbox logs contain
all allow and deny decisions that sandboxd was nice enough to log to the system log.
"""
import argparse
import os
import subprocess
import datetime

from misc.logger import create_logger
import misc.app_utils as app_utils
from misc.filesystem import project_path

from bundle.bundle import Bundle

logger = create_logger('rule_matching.gather_logs')


def process_app(app_path, outdir, timeout=60):
    if not (app_path.endswith(".app") or app_path.endswith(".app/")) and Bundle.is_bundle(app_path):
        logger.error(
            "Provided path {} is not a valid app. Skipping.".format(app_path)
        )
        return

    bundle = Bundle.make(app_path)
    if not bundle.is_sandboxed():
        logger.error(
            "Application at path {} is not sandboxed, therefore no sandbox traces will be collected.".format(app_path)
        )
        return

    # Make sure to let the sandbox run once, because we need the metadata generated by the
    # sandbox
    init_successful = app_utils.init_sandbox(bundle, logger)
    if not init_successful:
        logger.error("Failed to initialise sandbox for {}. Skipping.".format(app_path))
        return

    if os.path.isdir(outdir):
        logger.info("Skipping processing for {}, as output folder already exists.".format(app_path))
        return

    os.mkdir(outdir)

    # Use the existing interpreter to create a new sandbox profile
    # that logs every operation (all allowed ones) to the syslog
    sbpl = [project_path("sbpl/build/sbpl"), "--scheme", "--patch",
            "--bundle-id", bundle.bundle_identifier(),
            "--profile", project_path("sbpl/application.sb"),
            "--output", os.path.join(outdir, "patched_profile.sb")]

    subprocess.call(sbpl, cwd = project_path("sbpl"),
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL)

    # Also retains the JSON version, for matching purposes later on
    sbpl = [project_path("sbpl/build/sbpl"), "--json",
            "--bundle-id", bundle.bundle_identifier(),
            "--profile", project_path("sbpl/application.sb"),
            "--output", os.path.join(outdir, "patched_profile.json")]

    subprocess.call(sbpl, cwd = project_path("sbpl"),
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL)

    # Compile the profile using stefan esser's tool
    subprocess.call([project_path("testing/compile_sb"),
                     os.path.join(outdir, "patched_profile.sb"),
                     os.path.join(outdir, "patched_profile.bin")],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL)

    # The easiest way to make sure our patched profile is actually used would be
    # to hook the responsible methods in libsystem_secinit and make them load another
    # profile at runtime. Unfortunately, stock macOS kernels set the CS_RESTRICT flag on
    # applications that have entitlements and dyld will ignore all DYLD_ variables,
    # making this impossible without patching the kernel. (or patching dyld, but dyld is a
    # platform binary which further complicates this task)
    # However, one can simply modify the Container.plist metadata file. Simply modify the
    # SandboxProfileData embedded and the sandbox will happily use this profile.

    # Replace the sandbox profile data with our custom compiled profile (see above)
    # PlistBuddy is a useful program to do this.
    container_metadata = os.path.join(os.path.expanduser("~/Library/Containers"), bundle.bundle_identifier(), "Container.plist")
    assert os.path.isfile(container_metadata)

    subprocess.call([
        "/usr/libexec/PlistBuddy",
        "-c", "Import SandboxProfileData \"{}\"".format(os.path.join(outdir, "patched_profile.bin")),
        container_metadata
    ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

    # Record starting time
    start = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    logger.info("Starting {} to collect sandbox logs.".format(app_path))

    stdout_to = os.path.join(outdir, "process.stdout")
    stderr_to = os.path.join(outdir, "process.stderr")
    pid_to = os.path.join(outdir, "process.pid")

    with open(stdout_to, "w") as stdout_f, open(stderr_to, "w") as stderr_f, open(pid_to, "w") as pid_f:
        pid = app_utils.run_process(bundle.executable_path(), timeout, stdout_f, stderr_f)
        print("{}".format(pid), file = pid_f)

    end = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    with open(os.path.join(outdir, "sandbox_logs.json"), "wb") as sblogs:
        # Collect logs and store them at the output location
        process = subprocess.call(["log", "show",
                         "--start", start,
                         "--end", end,
                         "--style", "json",
                         "--predicate", 'senderImagePath == "/System/Library/Extensions/Sandbox.kext/Contents/MacOS/Sandbox"'],
                        stdout = sblogs)


def main():
    parser = argparse.ArgumentParser(description='Collect sandbox logs for an application run')
    parser.add_argument('--app', required=True,
                        help='Path to the app for which to collect sandbox logs.')
    parser.add_argument('--outdir', required=True,
                        help='Location where to store logfiles and sandbox profiles at.')
    parser.add_argument('--timeout', required=False, default=None, type=int,
                        help='Number of seconds to wait before killing the program. Leave unspecified to not kill the program at all.')
    args = parser.parse_args()

    process_app(args.app, args.outdir, timeout=args.timeout)


if __name__ == "__main__":
    main()
